1. add，OF、SF、ZF、AF、CF 和 PF 的状态依计算结果而定。
2. ，OF 和 CF 位被清零，SF、ZF、PF 位的状态依计算结果而定，AF 位的状态未定义
3. call，过程调用，8086 处理器支持四种调用方式：
    - 16 位相对近调用，近调用的意思是被调用的目标过程位于当前代码段内，而非另一个不同的代码段，所以只需要偏移地址即可：`call [near] proc_1`
    - 16 位间接绝对近调用，这种调用也是近调用，只能调用当前代码段内的过程，指令中的操作数不是偏移量，而是被调用过程的真实偏移地址，故称为绝对地址。不过，这个偏移地址不是直接出现在指令中，而是由 16 位的通用寄存器或者 16 位的内存单元间接给出：`call [near] cx` or `call [near] [0x3000]`
    - 16 位直接绝对远调用，这种调用属于段间调用，即调用另一个代码段内的过程，所以称为远调用（far call）。很容易想到，远调用既需要被调用过程所在的段地址，也需要该过程在段内的偏移地址。“16 位”是针对偏移地址来说的，而不是限定段地址，尽管段地址事实上也是 16 位的；“直接”的意思是，段地址和偏移地址直接在 call 指令中给出了。当然，这里的地址也是绝对地址：`call 0x2000:0x0030`，其中 0x2000 表示段地址；0x0030 表示偏移地址
    - 16 位间接绝对远调用，被调用的过程所在段地址和偏移地址是间接给出的。因为是远调用，也就是段间调用，所以，必须给出被调用过程的段地址和偏移地址。但是，段地址和偏移地址在内存中的其他位置，指令中仅仅给出的是该位置的偏移地址，需要处理器在执行指令时自行按图索骥，找到它们：`call for [0x2000]`
    - ret是近返回指令，当它执行时，处理器只做一件事，那就是从栈中弹出一个字到指令指针寄存器 IP 中。
    - retf 是远返回指令（return far），它的工作稍微复杂一点点。当它执行时，处理器分别从栈中弹出两个字到指令指针寄存器 IP 和代码段寄存器 CS 中。
5. cbw，Convert Byte to Word，将寄存器 AL 中的有符号数扩展到整个 AX。不影响任何标志位。
6. cmp，在功能上和 sub 指令相同，但 cmp 指令仅仅根据计算结果设置相应的标志位，而不保留计算结果
7. cld，DF=0，CF、OF、ZF、SF、AF 和 PF 未定义。
8. cwd，Convert Word to Double-word，将寄存器 AX 中的有符号数扩展到 DX:AX。不影响任何标志位。
9. dec，CF 标志不受影响，因为该指令通常在程序中用于循环计数，而且在循环中常用依赖 CF 标志的指令，故不希望它打扰 CF 标志；对 OF、SF、ZF、AF 和 PF 的影响依计算结果而定。
10. div，Unsigned Divide，无符号除法指令。对 CF、OF、SF、ZF、AF 和 PF 的影响未定义。
11. idiv，Signed Divide，有符号除法指令
12. inc，CF 标志不受影响，对 OF、SF、ZF、AF 和 PF 的影响依计算结果而定。
13. loop，先将 CX 的内容减一，然后，处理器根据 CX 是否为零来决定是否开始下一轮循环
14. jc/jo/jp/js 的意思是 CF/OF/PF/SF 标志为 1 则转移；jnc/jno/jnp/jns 的意思是 CF/OF/PF/SF 标志为 0 则转移
15. mov/movs 这类指令不影响任何标志位
16. neg，用 0 减去指令中指定的操作数。如果操作数为 0，则 CF=0，否则 CF=1；对 OF、SF、ZF、AF 和 PF 的影响依计算结果而定。
17. or，OF 和 CF 位被清零，SF、ZF、PF 位的状态依计算结果而定，AF 位的状态未定义
18. std，DF=1，不影响其他标志位
19. sub，对 OF、SF、ZF、AF、PF 和 CF 的影响依计算结果而定。
20. xor，OF=0，CF=0；对 SF、ZF 和 PF 依计算结果而定；对 AF 的影响未定义
